
#include "globals.h"
#include "scan.h"
#include "util.h"

#define BUFFERLENGTH 256

char lineText[BUFFERLENGTH];       /* text of the current line */
char tokenString[MAXTOKENLEN + 1]; /* lexeme of the current token */
int lineIndex = 0;                 /* current position in this line */
int lineSize = 0;                  /* size of the current line, in chars */

typedef enum
{
    START,
    INNUM,
    INID,
    INDIV,
    INCOMMENT,
    INCOMMENT2,
    INNE,
    INLT,
    INGT,
    INEQ,
    ERRORSTATE,
    DONE
} TokenState;

char reservedWords[MAXRESERVED][7] =
    {"int", "void", "if", "else", "return", "while"};

TokenType reservedWordsTokens[MAXRESERVED] =
    {INT, VOID, IF, ELSE, RETURN, WHILE};

/***********************************************************************
  The following code is automatically generated by the gperf(1) 
   minimal perfect hash function generator tool.
 ***********************************************************************/

/* C code produced by gperf version 2.7 */
/* Command-line: /tmp/n2251132/gperf-2.7/src/gperf -t gperfinput.txt  */

struct fastReservedWords
{
    char *name;
    TokenType tok;
};

#define TOTAL_KEYWORDS 6
#define MIN_WORD_LENGTH 2
#define MAX_WORD_LENGTH 6
#define MIN_HASH_VALUE 2
#define MAX_HASH_VALUE 9
/* maximum key range = 8, duplicates = 0 */

TokenType LookupReservedWord(char *lexeme)
{
    int i;
    for (i = 0; i < MAXRESERVED; ++i)
    {
        if (!strcmp(lexeme, reservedWords[i]))
            return reservedWordsTokens[i];
    }
    return ID;
}

static char getNextChar()
{
    if (lineIndex >= lineSize)
    {
        ++lineno;
        if (fgets(lineText, BUFFERLENGTH - 1, source))
        {
            lineSize = strlen(lineText);
            lineIndex = 0;
            if (EchoSource)
                fprintf(listing, "SOURCE: %5d: %s", lineno, lineText);
            return lineText[lineIndex++];
        }
        else
            return EOF;
    }
    return lineText[lineIndex++];
}

static void ungetNextChar()
{
    --lineIndex;
}

TokenType getToken(void)
{
    int tokenIndex = 0;       /* index into tokenString    */
    TokenType currentToken;   /* token to be returned      */
    TokenState state = START; /* FSA state                 */
    int save;                 /* save char to tokenString? */
    int c;                    /* character under examination */

    while (state != DONE)
    {
        c = getNextChar();
        save = TRUE; /* save this character into lexeme by default */

        switch (state)
        {
        case START:
            if (isdigit(c))
                state = INNUM;
            else if (isalpha(c))
                state = INID;
            else if (c == '/')
                state = INDIV;
            else if (c == '!')
                state = INNE;
            else if (c == '<')
                state = INLT;
            else if (c == '>')
                state = INGT;
            else if (c == '=')
                state = INEQ;
            else if ((c == 10) || (c == 13) || (c == 32))
                save = FALSE;
            else
            {
                state = DONE;
                switch (c)
                {
                case EOF:
                    save = FALSE;
                    currentToken = ENDOFFILE;
                    break;
                case '+':
                    currentToken = PLUS;
                    break;
                case '-':
                    currentToken = MINUS;
                    break;
                case '*':
                    currentToken = TIMES;
                    break;
                case ';':
                    currentToken = SEMI;
                    break;
                case ',':
                    currentToken = COMMA;
                    break;
                case '[':
                    currentToken = LSQUARE;
                    break;
                case ']':
                    currentToken = RSQUARE;
                    break;
                case '(':
                    currentToken = LPAREN;
                    break;
                case ')':
                    currentToken = RPAREN;
                    break;
                case '{':
                    currentToken = LBRACE;
                    break;
                case '}':
                    currentToken = RBRACE;
                    break;
                default:
                    currentToken = ERROR;
                    break;
                }
            }
            break;
        case INNE:
            state = DONE;
            if (c == '=')
                currentToken = NE;
            else
            {
                ungetNextChar();
                save = FALSE;
                currentToken = ERROR;
            }
            break;
        case INLT:
            state = DONE;
            if (c == '=')
                currentToken = LTE;
            else
            {
                ungetNextChar();
                save = FALSE;
                currentToken = LT;
            }
            break;
        case INGT:
            state = DONE;
            if (c == '=')
                currentToken = GTE;
            else
            {
                ungetNextChar();
                save = FALSE;
                currentToken = GT;
            }
            break;
        case INEQ:
            state = DONE;
            if (c == '=')
                currentToken = EQ;
            else
            {
                ungetNextChar();
                save = FALSE;
                currentToken = ASSIGN;
            }
            break;
        case INDIV:
            if (c == '*')
            {
                save = FALSE;
                state = INCOMMENT;
                tokenIndex -= 1;
            }
            else
            {
                ungetNextChar();
                save = FALSE;
                state = DONE;
                currentToken = DIVIDE;
            }
            break;
        case INCOMMENT:
            save = FALSE;
            if (c == '*')
                state = INCOMMENT2;
            else if (c == EOF)
                state = ERROR;
            break;
        case INCOMMENT2:
            save = FALSE;
            if (c == '/')
                state = START;
            else if (c == '*')
                state = INCOMMENT2;
            else
                state = INCOMMENT;
            break;
        case INID:
            if (!isalpha(c))
            {
                ungetNextChar();
                save = FALSE;
                state = DONE;
                currentToken = ID;
            }
            break;
        case INNUM:
            if (!isdigit(c))
            {
                ungetNextChar();
                save = FALSE;
                state = DONE;
                currentToken = NUM;
            }
            break;
        case DONE:
        default:
            fprintf(listing, "<<<SCANNER BUG>>: state = %d\n", state);
            state = DONE;
            currentToken = ERROR;
            break;
        }
        if ((save) && (tokenIndex <= MAXTOKENLEN))
            tokenString[tokenIndex++] = c;
        if (state == DONE)
        {
            tokenString[tokenIndex] = '\0';
            if (currentToken == ID)
                currentToken = LookupReservedWord(tokenString);
        }
    }
    if (TraceScan)
    {
        fprintf(listing, "Line: %5d: ", lineno);
        printToken(currentToken, tokenString);
        fprintf(listing, "\n");
    }
    return currentToken;
}